import winreg
import re
import time
import os

# Set the folder path for the log file
folderPath = os.path.join(os.environ["USERPROFILE"], "Documents", "CyberKombatData")
# Ensure the directory exists
os.makedirs(folderPath, exist_ok=True)
# Set the path for the log file
logFilePath = os.path.join(folderPath, "registry_log.dat")

# Define suspicious patterns
SUSPICIOUS_PATTERNS = [
    # Existing patterns ...
    # Scripting abuse
    re.compile(r'powershell\.exe\s-[Ee]nc', re.IGNORECASE),  # Encoded command
    re.compile(r'schtasks\s/CREATE', re.IGNORECASE),         # Scheduled task creation
    re.compile(r'[A-Za-z]:\\.*\.(bat|cmd)', re.IGNORECASE),  # Batch file execution
    re.compile(r'wmic\.exe', re.IGNORECASE),                 # WMIC usage
    re.compile(r'[A-Za-z]:\\.*\.(vbs|vbe|js|jse)', re.IGNORECASE),  # Script file types

    # Fileless Malware
    re.compile(r'Invoke-Expression', re.IGNORECASE),        # PowerShell Invoke-Expression
    re.compile(r'IEX\s', re.IGNORECASE),                     # Alias for Invoke-Expression
    re.compile(r'Invoke-Mimikatz', re.IGNORECASE),          # Commonly used in memory credential scraping attacks
    re.compile(r'Invoke-Shellcode', re.IGNORECASE),         # Executes shellcode directly in memory
    re.compile(r'Invoke-ReflectivePEInjection', re.IGNORECASE),  # Reflective PE injection technique

    # Persistence mechanisms
    re.compile(r'HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Run', re.IGNORECASE),
    re.compile(r'HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\Run', re.IGNORECASE),
    re.compile(r'setx\s', re.IGNORECASE),                   # Environment variable manipulation

    # Network and exfiltration activities
    re.compile(r'net\suse', re.IGNORECASE),                 # Network share mapping
    re.compile(r'net1\suse', re.IGNORECASE),                # Alternative command for 'net use'
    re.compile(r'ftp\.exe', re.IGNORECASE),                 # FTP command-line tool
    re.compile(r'tftp', re.IGNORECASE),                     # Trivial File Transfer Protocol

    # Evasion and anti-analysis
    re.compile(r'whoami', re.IGNORECASE),                   # User information gathering
    re.compile(r'systeminfo', re.IGNORECASE),               # System information gathering
    re.compile(r'netstat\s-ano', re.IGNORECASE),            # Network connections and listening ports
    re.compile(r'tasklist', re.IGNORECASE),                 # List running processes
    re.compile(r'attrib\s\+h', re.IGNORECASE),              # Hide file attributes

    # Credential Access and Privilege Escalation
    re.compile(r'net\suser\s', re.IGNORECASE),              # Adding or modifying user accounts
    re.compile(r'net\slocalgroup\sadministrators', re.IGNORECASE),  # Add user to administrators group
    re.compile(r'netsh\sfirewall\sset', re.IGNORECASE),     # Modifying firewall settings
    re.compile(r'netsh\sadvfirewall\sset', re.IGNORECASE),  # Modifying advanced firewall settings

    # Malware and tool specific
    re.compile(r'mimikatz', re.IGNORECASE),                 # Well-known credential dumping tool
    re.compile(r'cobaltstrike', re.IGNORECASE),             # Common command and control framework
    re.compile(r'meterpreter', re.IGNORECASE),              # Metasploit payload
    re.compile(r'nc\.exe', re.IGNORECASE),                  # Netcat tool
    re.compile(r'plink\.exe', re.IGNORECASE),               # SSH client commonly used for port forwarding

    # Suspicious file paths and names
    re.compile(r'C:\\Users\\.*\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup', re.IGNORECASE),  # Startup folder path
    re.compile(r'C:\\Windows\\Temp\\', re.IGNORECASE),      # Windows temp directory
    re.compile(r'C:\\Windows\\System32\\', re.IGNORECASE),  # System32 directory
    re.compile(r'~\$', re.IGNORECASE),                      # Temporary files generated by Office applications
    re.compile(r'[^A-Za-z]tmp[^A-Za-z]', re.IGNORECASE),    # File names containing 'tmp' outside of words

    # more  patterns needed  research_from(threat intelligence, incident reports, and malware analysis findings)
]

# Define registry locations for monitoring
REGISTRY_LOCATIONS = {
    "Autostart": [
        (winreg.HKEY_LOCAL_MACHINE, r"Software\Microsoft\Windows\CurrentVersion\Run"),
        (winreg.HKEY_CURRENT_USER, r"Software\Microsoft\Windows\CurrentVersion\Run"),
        (winreg.HKEY_LOCAL_MACHINE, r"Software\Microsoft\Windows\CurrentVersion\RunOnce"),
        (winreg.HKEY_CURRENT_USER, r"Software\Microsoft\Windows\CurrentVersion\RunOnce"),
        (winreg.HKEY_LOCAL_MACHINE, r"SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\Explorer\Run"),
        (winreg.HKEY_CURRENT_USER, r"SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\Explorer\Run"),
    ],
    "Services": [
        (winreg.HKEY_LOCAL_MACHINE, r"System\CurrentControlSet\Services"),
    ],
    "DLL Hijacking": [
        (winreg.HKEY_LOCAL_MACHINE, r"SOFTWARE\Microsoft\Windows NT\CurrentVersion\Windows", "AppInit_DLLs"),
    ],
    "Shell Extensions": [
        (winreg.HKEY_LOCAL_MACHINE, r"SOFTWARE\Microsoft\Windows\CurrentVersion\Shell Extensions\Approved"),
    ],
    "Scheduled Tasks": [
        (winreg.HKEY_LOCAL_MACHINE, r"SOFTWARE\Microsoft\Windows NT\CurrentVersion\Schedule\TaskCache\Tree"),
    ],
    "Browser Hijacking": [
        (winreg.HKEY_CURRENT_USER, r"Software\Microsoft\Internet Explorer\Main", "Start Page"),
        (winreg.HKEY_CURRENT_USER, r"Software\Microsoft\Internet Explorer\SearchScopes"),
    ],
    "Office Security": [
        (winreg.HKEY_CURRENT_USER, r"Software\Microsoft\Office\16.0\Word\Security"),
    ],
    "Security Software": [
        (winreg.HKEY_LOCAL_MACHINE, r"SOFTWARE\Microsoft\Windows Defender"),
    ],
}

# Function to write to both file and stdout
def log_output(message, end='\n'):
    with open(logFilePath, 'a', encoding='utf-8') as f:
        f.write(message + end)
    print(message, end=end)

# Helper functions
def convert_data_to_string(value, type):
    if type in (winreg.REG_SZ, winreg.REG_EXPAND_SZ, winreg.REG_LINK):
        return value.lower()
    elif type == winreg.REG_MULTI_SZ:
        return ' '.join(value).lower()
    elif type == winreg.REG_DWORD:
        return str(value)
    elif type == winreg.REG_BINARY:
        return ''.join(format(b, '02x') for b in value)
    return str(value).lower()

def log_suspicious_entry(path, name, value, reason):
    log_output(f"Suspicious entry detected: {path}\\{name}")
    log_output(f"Value: {value}")
    log_output(f"Reason: {reason}\n")

def matches_pattern(value):
    for pattern in SUSPICIOUS_PATTERNS:
        if pattern.search(value):
            return True
    return False

# Main function for checking entries
def check_suspicious_entries(hive, path, value_name=None):
    try:
        with winreg.OpenKey(hive, path, access=winreg.KEY_READ) as regkey:
            i = 0
            while True:
                try:
                    name, value, type = winreg.EnumValue(regkey, i)
                    data_str = convert_data_to_string(value, type)
                    if matches_pattern(data_str):
                        log_suspicious_entry(path, name, value, "Matched suspicious pattern")
                    i += 1
                except EnvironmentError:  # Ends when there are no more values
                    break
    except FileNotFoundError:  # Catching file not found error specifically
        log_output(f"Registry path not found: {path}")
    except EnvironmentError as e:  # For handling other permissions and errors
        log_output(f"Error accessing {path}: {e}")

def check_registry_changes(previous_state, current_state):
    # Compare previous and current states of registry keys
    for key in current_state:
        if key not in previous_state or previous_state[key] != current_state[key]:
            log_output(f"Change detected in registry key: {key}")
            log_output(f"Old value: {previous_state.get(key, 'N/A')}")
            log_output(f"New value: {current_state[key]}")

def snapshot_registry(hive, path):
    # Take a snapshot of registry keys and values
    snapshot = {}
    try:
        with winreg.OpenKey(hive, path, access=winreg.KEY_READ) as regkey:
            i = 0
            while True:
                try:
                    name, value, _ = winreg.EnumValue(regkey, i)
                    snapshot[name] = value
                    i += 1
                except EnvironmentError:  # Ends when there are no more values
                    break
    except EnvironmentError as e:
        print(f"Error accessing {path}: {e}")
    return snapshot                    

# Function to monitor registry continuously
def monitor_registry():
    # Initialize the previous state dictionary to hold snapshots of registry keys
    previous_states = {}

    try:
        for category, paths in REGISTRY_LOCATIONS.items():
            log_output(f"Checking {category}...")

            for entry in paths:
                hive, path = entry[:2]  # Ensure only two items are unpacked
                value_name = entry[2] if len(entry) > 2 else None  # Handles optional value name

                # Take a snapshot of the current state of the registry key
                current_state = snapshot_registry(hive, path)

                # If we have a previous state, compare it to the current state
                if (hive, path) in previous_states:
                    check_registry_changes(previous_states[(hive, path)], current_state)

                # Update the previous_states dictionary with the current state for future comparison
                previous_states[(hive, path)] = current_state

                # Check for suspicious entries based on patterns (original functionality)
                check_suspicious_entries(hive, path, value_name)
    except KeyboardInterrupt:
        log_output("\nScript stopped by user. Exiting...")

if __name__ == "__main__":
    monitor_registry()